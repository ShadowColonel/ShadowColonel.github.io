[{"title":"Gradle一些碎片知识点","date":"2017-07-10T06:51:58.000Z","path":"2017/07/10/Gradle一些碎片知识点/","text":"gradle插件版本配置位置：12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.2.3&apos; &#125;&#125; gradle版本配置位置：gradle-wrapper.properties 中1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.2-all.zip 版本对应如图： Plugin version Required Gradle version 1.0.0-1.1.3 2.2.1-2.3 1.2.0-1.3.1 2.2.1-2.9 1.5.0 2.2.1-2.13 2.0.0-2.1.2 2.10-2.13 2.13-2.2.3 2.14.1+ 2.3.0+ 3.3+ 12345678910111213141516buildscript &#123; repositories &#123; &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.3&apos; &#125;&#125;allprojects &#123; repositories &#123; &#125;&#125; buildscript里是gradle脚本执行所需依赖，分别对应的maven库和插件 allprojects里是项目本身需要的依赖 maven仓库 类型 说明 Maven central repository Maven的中央仓库，无需配置，声明即可使用。不支持https协议访问 Maven JCenter repository JCenter中央仓库，实际也是用maven搭建的，但相比Maven仓库更友好，通过CDN分发，并且支持https访问。 Maven local repository Maven本地仓库，可以通过本地配置文件进行配置 Maven repository 常规的第三方Maven仓库，可设置访问Url Ivy repository Ivy仓库，可以是本地仓库，也可以是远程仓库 Flat directory repository 使用本地文件夹作为仓库 各种Maven仓库在gradle中的配置方法 Maven central repository 123repositories &#123; mavenCentral()&#125; Maven JCenter repository 123repositories &#123; jcenter()&#125; 指定仓库，指定链接使用。 比如JCenter仓库是通过https访问的，如果想切换成http协议访问，修改配置：12345repositories &#123; jcenter&#123; url &quot;http://jcenter.bintray.com&quot; &#125;&#125; Local Maven repository-可以使用Maven本地的仓库。默认情况下，本地仓库位于USER_HOME/.m2/repository（例如windows环境中，在C:\\Users\\NAME.m2.repository），同时可以通过USER_HOME/.m2/下的settings.xml配置文件修改默认路径位置。 123repositories &#123; mavenLocal()&#125; Maven repository 第三方的配置也很简单，直接指明url即可：12345repositories &#123; maven &#123; url &quot;http://repo.mycompany.com/maven2&quot; &#125;&#125; Ivy repository 12345repositories &#123; ivy &#123; url &quot;http:/repo.mycompany.com/repo&quot; &#125;&#125; Flat directory repository使用本地文件夹，这个也比较常用，直接在build.gradle中声明文件夹路径： 12345678repositories &#123; flatDir &#123; dirs &apos;lib&apos; &#125; flatDir &#123; dirs &apos;lib1&apos;, &apos;lib2&apos; &#125;&#125; 使用本地文件夹时，就不支持配置元数据格式的信息了（POM文件）。并且Gradle会优先使用服务器仓库中的库文件：例如时事声明了jcenter和flatDir，当flatDir中的库文件同样在jcenter中存在，gradle会优先使用jcenter的。","tags":[{"name":"gradle","slug":"gradle","permalink":"//six41.me/tags/gradle/"},{"name":"repository","slug":"repository","permalink":"//six41.me/tags/repository/"},{"name":"maven","slug":"maven","permalink":"//six41.me/tags/maven/"}]},{"title":"Gradle配置优化","date":"2017-07-10T06:38:17.000Z","path":"2017/07/10/Gradle配置优化/","text":"基础定义so库引入 常规引入放入对应的文件夹，系统自动引入 123456789app ├── AndroidManifest.xml └── jniLibs ├── armeabi │ └── yuancloud.so ├── armeabi-v7a │ └── yuancloud.so └── x86 └── yuancloud.so 放在lib文件夹下在sourceSets中设置： 12345sourceSets &#123; main &#123; jniLibs.srcDirs = [&apos;libs&apos;] &#125;&#125; aar文件引入aar相当于Android Library的输出库，其中包含资源文件。放入lib文件夹，依赖方式：1234567891011android &#123; repositories &#123; flatDir &#123; dirs &apos;libs&apos; &#125; &#125;&#125;dependencies &#123; compile(name: &apos;***&apos;, ext: &apos;aar&apos;)&#125; sourceSets资源设置字段，当项目从eclipse转到android studio上时，文件结构不同，可以设置sourceSets，默认设置如下：123456789101112sourceSets &#123; main &#123; manifest.srcFile &apos;AndroidManifest.xml&apos; java.srcDirs = [&apos;src&apos;] resources.srcDirs = [&apos;src&apos;] aidl.srcDirs = [&apos;src&apos;] renderscript.srcDirs = [&apos;src&apos;] res.srcDirs = [&apos;res&apos;] assets.srcDirs = [&apos;assets&apos;] jniLibs.srcDirs = [&apos;libs&apos;] &#125; &#125; 多渠道打包简单渠道定义不做任何定制，只提供驱动名称，在需要在module中的build.gradle，android作用域中添加添加productFlavors：1234567891011121314151617productFlavors &#123; xiaomi &#123; &#125; googlepaly &#123; &#125; huawei &#123; &#125; meizu &#123; &#125; baidu &#123; &#125;&#125; Android Studio的BuildVariant就会有相应的渠道，如图所示： 自定义Gradle组件为多渠道打包提供了许多方便的方法，开发者可以根据不同的渠道配置打包不同的apk，例如文件名，包名，编译资源等等。 不同渠道编译不同包名 12345678productFlavors &#123; xiaomi &#123; applicationId &apos;com.xiaomi.pro&apos; &#125; meizu &#123; applicationId &apos;com.meizu.pro&apos; &#125;&#125; 不同渠道编译指定不同的资源类型用上述提到的sourceSets字段，可以自定义指定编译的资源路径： 12345678910111213141516productFlavors &#123; xiaomi &#123; applicationId &apos;com.xiaomi.pro&apos; //以下指定编译资源// java.srcDirs = [&apos;src/main1&apos;, &apos;src/main1/java&apos;]// res.srcDirs = [&apos;src/main1/res&apos;]// assets.srcDirs = [&apos;assets1&apos;] &#125; googleplay &#123; applicationId &apos;com.googleplay.pro&apos; //以下指定编译资源// java.srcDirs = [&apos;src/main2&apos;, &apos;src/main2/java/&apos;]// res.srcDirs = [&apos;src/main2/res&apos;]// assets.srcDirs = [&apos;assets2&apos;] &#125; &#125; 自定义打包apk名称 12345678910111213141516171819//修改输出apk名字applicationVariants.all &#123; variant -&gt; if (variant.buildType.name.equals(&apos;release&apos;)) &#123; variant.outputs.each &#123; output -&gt; def appName = &apos;AGradle&apos; def oldFile = output.outputFile def buildName def releaseApkName variant.productFlavors.each &#123; product -&gt; buildName = product.name &#125; releaseApkName = appName + getVersionByMainfest() + &apos;-&apos; + buildName + &apos;-&apos; + getNowTime() + &apos;.apk&apos; output.outputFile = new File(oldFile.parent, releaseApkName) &#125; &#125;&#125; 渠道统一配置如果需要在不同渠道统一配置，可以使用productFlavors.all字段： 123productFlavors.all &#123; //&#125; 一些优化使用技巧占位符上面提到过进行多渠道打包时，可以根据渠道不同自定义不同的包名。然而在一些第三方平台上，一般是根据包名和签名信息申请得到appkey。例如，百度地图，微信，我们需要在AndroidManifest中配置meta-data。 当我们在Manifest文件中定义一个变量时，可以用manifestPlaceholders在build.gradle中动态替换变量，例如：123&lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;$&#123;umeng_app_key&#125;&quot;/&gt; 然后，在build.gradle文件中根据不同环境，生成不同appkey。1manifestPlaceholders = [umeng_app_key: &quot;你替代的内容&quot;] 在多渠道中：12345678910productFlavors &#123; xiaomi &#123; applicationId &apos;com.xiaomi.pro&apos; manifestPlaceholders = [umeng_app_key: &quot;xiaomi_appkey&quot;] &#125; meizu &#123; applicationId &apos;com.meizu.pro&apos; manifestPlaceholders = [umeng_app_key: &quot;meizu_appkey&quot;] &#125;&#125; 多个变量用逗号隔开。 BuildConfigBuildConfig，是在我们module中的build.gradle配置正确，编译成功后，自动生成的配置文件，一般默认为以下代码：12345678public final class BuildConfig &#123; public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;); public static final String APPLICATION_ID = &quot;com.pretang.guest&quot;; public static final String BUILD_TYPE = &quot;debug&quot;; public static final String FLAVOR = &quot;meizu&quot;; public static final int VERSION_CODE = 1; public static final String VERSION_NAME = &quot;1.0&quot;;&#125; BuildConfig.java无法手动进行编译，但它由gradle进行动态控制。由两个关键词：buildConfigField和resValue。看如下代码段：123456789101112buildTypes &#123; debug &#123; buildConifgField &apos;String&apos;, &apos;STATE_TEST&apos;, &quot;debug&quot; resValue &apos;String&apos;, &apos;test_value&apos;, &quot;AGradle_debug&quot; &#125; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; buildConfigField &apos;String&apos;, &apos;STATE_TEST&apos;, &quot;release&quot; resValue &apos;String&apos;, &apos;test_value&apos;, &quot;AGradle_release&quot; &#125;&#125; buildConfigFieldbuildConfigField会根据gradle的配置，在原来的BuildConfig.java中，动态添加指定数据类型的value。buildConifgField一共有三个参数，第一个是数据类型，第二个是常量名，第三个是常量值。 resValuebuildConfigField主要改变了java常量，resValue可以通过gradle动态配置管理资源文件，其生成的目标存在generated.xml中。使用规则与buildConfigField类似，即类型+常量名+常量值 全局配置 新建全局配置guestmgr.gradle，里面的内容如下： 12345678910111213141516171819202122//通用配置ext &#123; //android BUILD_SDK_VERSION = 23 BUILD_TOOLS_VERSION = &quot;23.0.2&quot; //build config MIN_SDK_VERSION = 18 TARGT_SDK_VERSION = 24 VERSION_CODE = 1 VERSION_NAME = &quot;1.0&quot; //siging KEY_ALIAS = &apos;***&apos; KEY_PASSWORD = &apos;****&apos; KEY_FILEPATH =&quot;../pre.jks&quot; KEY_STORE_PASSWORD = &apos;****&apos; //appkey UMENG_CHANNEL_VALUE_XIAOMI = &apos;XIAOMI_APPKEY&apos; UMENG_CHANNEL_VALUE_HUAWEI = &apos;HUAWEI_APPKEY&apos;&#125; 在project的build.gradle应用这个gradle配置 1apply from: &apos;guestmgr.gradle&apos; module中的build.gradle使用ext中的自定义常量 12345678910compileSdkVersion BUILD_SDK_VERSIONbuildToolsVersion BUILD_TOOLS_VERSIONdefaultConifg &#123; applicationId &apos;com.pretang.guestmgr&apos; minSdkVersion MIN_SDK_VERSION targetSdkVersion TARGET_SDK_VERSION versionCode VERSION_CODE versionName VERSION_NAME&#125; 使用gradle.properties这个跟全局gradle作用类似，区别就是全局的gradle定义了ext，而gradle.properties是直接提供配置参数。 在gradle.properties中写入配置参数 123456789// androidBUILD_SDK_VERSION = 23BUILD_TOOLS_VERSION = 23.0.2//build configMIN_SDK_VERSION = 18TARGT_SDK_VERSION = 24VERSION_CODE = 1VERSION_NAME = 1.0 module中使用 1234567891011compileSdkVersion BUILD_SDK_VERSION as int //SDK编译版本buildToolsVersion BUILD_TOOLS_VERSION//构建工具版本 对应buildTooldefaultConfig &#123; applicationId &quot;com.yuan.agradle&quot; //配置包名 minSdkVersion MIN_SDK_VERSION as int // 最小支持sdk版本 targetSdkVersion TARGT_SDK_VERSION as int// 目标sdk版本 versionCode VERSION_CODE as int//版本号 versionName VERSION_NAME //版本名称&#125; 使用as int是因为gradle.properties配置信息是字符串格式，如果我们输入的常量是整形的时候，必须通过as int进行类型转化。 常见配置 (待完善) dexOptions compileOptions aaptOptions lintOptions1234lintOptions &#123; abortOnError false //即使报错也不会停止打包 checkReleaseBuilds false //打包release版本的时候进行检测 &#125;","tags":[{"name":"gradle","slug":"gradle","permalink":"//six41.me/tags/gradle/"}]}]